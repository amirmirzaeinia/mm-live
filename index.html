<style>
    .axis {
        font-family: sans-serif;
        font-size: 20px;
        font-family: 'Helvetica Neue';
    }
    .yaxis {
        fill: #183660;
    }
    .y2axis {
        fill: #9E0000;
    }
    .line {
        fill: none;
        stroke: #f1c40f;
        stroke-width: 3px;
    }
    .smoothline {
        fill: none;
        //stroke: #d466ee;
        stroke-width: 3px;
    }
    .area {
        fill: #e74c3c;
        opacity: 0.5;
    }
    .circle {
        stroke: #e74c3c;
        stroke-width: 3px;
        fill: #FFF;
    }
    .grid {
        stroke: #EEE;
        stroke-width: 1px;
        fill: none;
    }
    .dark-grid {
        stroke: #000;
        stroke-width: 2px;
        fill: none;
    }
</style>
<div style="display:inline">
<svg id="y1axis" width="102"></svg>
<svg id="chart"></svg>
<svg id="y2axis"></svg>
</div>
<script src="http://d3js.org/d3.v4.min.js"></script>
<script>
    var groups = {
        sum : {
            data : [],
            color : '#183660',
        },
        delay : {
            data : [],
            color : '#9E0000',
        }
    };
    var q = [{'t' : 0, 'sum' : 0, 'delay' : 0}]
    var width = 800;
    var height = 400;
    var g_left = 0;
    var g_right = 750;
    var g_bottom = height - 100;
    var globalX = 0;
    var duration = 500;
    var max = 10;
    var step = 0.5;
    var max_points = (max / step);

    var chart = d3.select('#chart')
    .attr('width', g_right)
    .attr('height', height);
    var svg_y1 = d3.select('#y1axis')
    .attr('height', height);
    var svg_y2 = d3.select('#y2axis')
    .attr('height', height);
    var x = d3.scaleLinear().domain([0, width]).range([0, width]);
    var y = d3.scaleLinear().domain([0, g_bottom]).range([g_bottom, 0]);
    var y2 = d3.scaleLinear().domain([0, g_bottom]).range([g_bottom, 0]);
    // -----------------------------------
    var line = d3.line()
                        .x(function(d){ return x(d.x); })
                        .y(function(d){ return y(d.y); });
    var smoothLine = d3.line().curve(d3.curveBasis)
                        .x(function(d){ return x(d.x); })
                        .y(function(d){ return y(d.y); });

    // Draw the axis
    var xAxis = d3.axisBottom().scale(x);
    var axisX = chart.append('g').attr('class', 'xaxis axis')
                 .attr('transform', 'translate(' + g_left + ', ' + g_bottom + ')')
                 .call(xAxis);

    var yAxis = d3.axisLeft().scale(y);
    var axisY = svg_y1.append('g').attr('class', 'yaxis axis')
                 .attr('transform', 'translate(100,0)')
                 .call(yAxis);
    var y2Axis = d3.axisRight().scale(y2);
    var axisY2 = svg_y2.append('g').attr('class', 'y2axis axis')
                 .attr('transform', 'translate(1,0)')
                 .call(y2Axis);
    // -----------------------------------
    // Draw the grid
    for (var col = 50; col < width; col+= 50) {
        chart.append('path').datum([{x: col, y: 0}, {x: col, y: g_bottom}])
                    .attr('class', 'grid')
                    .attr('d', line);
    }
    chart.append('path').datum([{x: 0, y: 150}, {x: width, y: 150}])
                        .attr('class', 'grid')
                        .attr('d', line);
    chart.append('path').datum([{x: 0, y: 300}, {x: width, y: 300}])
                        .attr('class', 'grid')
                        .attr('d', line);
    chart.append('path').datum([{x: 0, y: 450}, {x: width, y: 450}])
                        .attr('class', 'grid')
                        .attr('d', line);


    // -----------------------------------
    // Draw the axis labels
    chart.append('text')
            .attr('class', 'axis')
            .attr('transform', 'translate(' + (width / 2) + ',' + (g_bottom + 70) + ')')
            .style('text-anchor', 'middle')
            .text('Time (seconds since start)')


    // Append the holder for line chart and fill area
    var paths = chart.append('g');
    for (var name in groups) {
        var group = groups[name]
        group.path = paths.append('path')
                        .datum(group.data)
                        .attr('stroke', group.color);
    }
    //var path = chart.append('path');
    // var areaPath = chart.append('path');
    // Main loop
    var waiting = false;
    function tick() {
        // Generate new data


        if (q.length <= 0) {
            waiting = true;
            return;
        }
        waiting = false;

        var m = q.shift();
        globalX = m['t']

        console.log(globalX);
        for (var name in groups) {
            var group = groups[name];
            group.data.push({
                x : globalX,
                y: m[name] // ((Math.random() * 200 + 50) >> 0) // m[name],
            });
            group.path.attr('d', smoothLine)
                .attr('class', 'smoothline');

        }
        //globalX += step;

        console.log(x(globalX - max))

        x.domain([globalX - (max - step), globalX]);
        axisX.transition()
             .duration(duration)
             .ease(d3.easeLinear,2)
             .call(xAxis);
        paths.attr('transform', null)
            .transition()
            .duration(duration)
            .ease(d3.easeLinear,2)
            .attr('transform', 'translate(' + x(globalX - max) + ')')
            .on('end', tick)
        if (globalX > max_points) {
            for (var name in groups) {
                groups[name].data.shift();
            }
        }
    }

    tick();

    var t = 0;
    setInterval(function() {
        console.log("timeout!");
        var before = q.length;
        q.push({
            t: t,
            sum: ((Math.random() * 200 + 50) >> 0),
            delay: ((Math.random() * 200 + 50) >> 0)
        });
        t+=0.5;
        if (waiting) {
            tick();
        }
    }, 700);

    wsock = new WebSocket("ws://localhost:8080");
    wsock.onopen = function(e) {
        console.log("Connected!");
    };
    wsock.onmessage = function(e) {
        // msg = {t :, sum :, delay : }
        q.push(JSON.parse(e.data));
        if (waiting) tick();
    };

</script>