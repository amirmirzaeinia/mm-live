<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">

        <style>
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        .graph .axis {
            stroke-width: 1;
        }

        .graph .axis .tick line {
            stroke: black;
        }

        .graph .axis .tick text {
            fill: black;
            font-size: 1em;
        }

        .yoneaxis {
            font-size: 1.3em;
            fill: purple;
        }

        .ytwoaxis {
            font-size: 1.3em;
            fill: #56b4e9;
        }

        .graph .axis .domain {
            fill: none;
            stroke: black;
        }

        .graph .group {
            fill: none;
            stroke: black;
            stroke-width: 1.5;
        }
        </style>
    </head>
    <body>
        <div class="graph" style="margin-left:50px;margin-top:50px;"></div>

        <h2>Bottleneck Link: 48Mbps, 50ms RTT, 1BDP buffering</h2>

        <script src="http://d3js.org/d3.v3.min.js"></script>
				<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"></script>
        <script>

        var width_seconds = 60,
            animation_duration_ms = 500,
            now = 0 - width_seconds;

        var g_width = 1400,
            g_height = 300

        var groups = {
            sum: {
                value: 0,
                color: 'purple',
                data: d3.range(width_seconds).map(function() {
                    return 0
                })
            },
            delay: {
                value: 0,
                color: '#56b4e9',
                data: d3.range(width_seconds).map(function() {
                    return 0
                })
            }
        }

        var x = d3.scale.linear()
              .domain([0, width_seconds])
              .range([0,g_width])

        var y = d3.scale.linear()
            .domain([0, 120])
            .range([g_height, 0])

        var line = d3.svg.line()
            .interpolate('basis')
            .x(function(d, i) {
                //return x(start - (width_seconds - 1 - i) * duration);
                return x()
            })
            .y(function(d) {
                return y(d) 
            })

        var svg = d3.select('.graph').append('svg')
            .attr('class', 'chart')
            .attr('width', g_width)
            .attr('height', g_height + 50)

        var axis = svg.append('g')
            .attr('class', 'x axis')
            .attr('transform', 'translate(0,' + g_height + ')')
            .call(x.axis = d3.svg.axis().scale(x).orient('bottom'));
        axis.selectAll("text").remove();

	
        var yscale = d3.svg.axis().scale(y).orient('left').tickValues(d3.range(10,120,10));

        var yaxis = svg.append('g')
        	.attr('class','y axis')
        	.attr('transform', 'translate(60,0)')
        	.call(yaxis = yscale);

        svg.append("text")
            .attr('class', 'yoneaxis')
            .attr('transform', 'translate(600,50) rotate(0)')
            .style("text-anchor", "middle")
            .text("Rate (Mbps) ")
        svg.append("text")
            .attr('class', 'ytwoaxis')
            .attr('transform', 'translate(900,50) rotate(0)')
            .style("text-anchor", "middle")
            .text("Queueing Delay (ms)")

        svg.append("text")
            .attr('class', 'axislabel')
            .attr('transform', 'translate(725,350) ')
            .style("text-anchor", "middle")
            .text("Time")

        var paths = svg.append('g')

        for (var name in groups) {
            var group = groups[name]
            group.path = paths.append('path')
                .data([group.data])
                .attr('class', name + ' group')
                .style('stroke', group.color)
        }

        var que = [{'t':0,'sum':0,'delay':0}];

        function tick() {
            // Get next queue element
            if (que.length <= 0) {
                    setTimeout(tick, duration);
                    return;
            }
            var m = que.shift();

            now = m['t']; // new Date(start.getTime() + (m['t'] * 1000));

            // Add new values
            for (var name in groups) {
                var group = groups[name]
                //group.data.push(group.value) // Real values arrive at irregular intervals
                //group.data.push(Math.random() * 100)
                group.data.push(m[name]);
                group.path.attr('d', line)

            }

            // Shift domain
            x.domain([now - (width_seconds - 2), now])

            // Slide x-axis left
            axis.transition()
                .duration(duration)
                .ease('linear')
                .call(x.axis)

            // Slide paths left
            paths.attr('transform', null)
                .transition()
                .duration(animation_duration_ms)
                .ease('linear')
                .attr('transform', 'translate(' + x(now - (width_seconds - 1)) + ')')
                .each('end', tick)

            // Remove oldest data point from each group
            for (var name in groups) {
                var group = groups[name]
                group.data.shift()
            }
        }

        var socket = io();
        var last_time = new Date();
        var since_last = 0;
        var count = 0;
        var total = 0;
        var last = 0, beta = 0;
        socket.on('data', function(m) {
                var curr = que.length;
                count += 1;
                since_last = ( ((new Date()) - last_time)/1000  );
                total += since_last;
                console.log(since_last, total / count);
                last_time = new Date();


                if ((curr-last) <= -2) {
                        animation_duration_ms += beta;
                        last = 0;
                } else if ((curr-last) >= 3) {
                        animation_duration_ms -= beta;
                        last = curr;
                }

                que.push(m);
        });

        //tick();

    </script>
</body>
</html>
